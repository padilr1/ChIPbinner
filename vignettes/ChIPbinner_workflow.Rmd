---
title: "Analyzing binned ChIP-seq/Cut&Run data with ChIPbinner"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analyzing binned ChIP-seq/Cut&Run data with ChIPbinner}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ChIPbinner)
```

```{r,include=FALSE}
library(formatR)
library(knitr)
```

# Example workflow for generating binned BED files

For input into ChIPbinner, the sequenced samples will need to be binned into windows, and formatted as a <a href="https://genome.ucsc.edu/FAQ/FAQformat">BED</a> file. One of the tools that can be used to perform this task is using <a href="https://bedtools.readthedocs.io/en/latest/">BEDtools</a> to convert an aligned sequence file, which is typically found in a <a href="https://genome.ucsc.edu/goldenPath/help/bam.html">BAM</a> format, into a binned BED file as demonstrated below.

```{bash,eval=FALSE}
# convert aligned BAM file to BED file
bedtools bamtobed -i ${sample}.sorted.bam | sort -k1,1 -k2,2n > ${sample}.bed
# intersect sample BED file with binned reference files
bedtools intersect -a $WINDOW_REF -b ${sample}.bed -sorted -c -nonamecheck > $OUTPUT_NAME.binned.bed
# example for binning Cal27 WT sample into 10kb windows
bedtools bamtobed -i Cal27.WT.H3K36me2.sorted.bam | sort -k1,1 -k2,2n > Cal27.WT.H3K36me2.bed
bedtools intersect -a hg38.10kb.windows.bed -b Cal27.WT.H3K36me2.bed -sorted -c -nonamecheck > Cal27.WT.H3K36me2.10kb.bed
```

# Generating normalized bigwig files

When you bin your files into windows, especially from aligned (bam or sam) files, they are typically raw read counts. They will need to be normalized by the input (highly recommended for ChIP-seq data) and likely scaled by some factor (we recommend using a normalization scaling factor like genome-wide modification percentage information obtained from mass spectrometry, Drosophila spike-in or any other types of spike-in). This step will have to be performed prior to moving on to the rest of the workflow.

Here, we are generating normalized bigwig files for 10kb-binned files (in BED format) for a head and neck squamous cell carcinoma (HNSCC) line (Cal27) for the broad histone mark H3K36me2 generated via ChIP-seq. The lysine 36 methyl transferase NSD1 was knocked out in the sample (NSD1-KO) and is being compared to the wildtype (WT) cell line. Please see
<a href="https://www.sciencedirect.com/science/article/pii/S2211124721000826?via%3Dihub">Farhangdoost et al. 2021</a> for more details. We will be using the <code>hg38</code> assembly for this analysis. 

This code chunk assumes your files are binned in 10kb windows and in the format <code>cell_line.sample_label.histone_mark.window_size_in_kb.bed</code>. Additionally, it assumes the control/input files associated with your samples are also in the same format. Please see below for example formats. The files below are included with the package and can be accessed using <code>system.file("extdata","file.bed",package = "ChIPbinner")</code>:
<ul>
<li> Cal27.WT.H3K36me2.10kb.bed</li>
<li> Cal27.WT_input.H3K36me2.10kb.bed</li>
<li> Cal27.NSD1_KO.H3K36me2.10kb.bed</li>
<li> Cal27.NSD1_KO_input.H3K36me2.10kb.bed</li>
</ul>

If you've ran the code chunk successfully, your resulting bigwig files will be found in the <code>output_directory</code> that you specified when running the function.
```{r,eval=FALSE,tidy=TRUE, tidy.opts=list(width.cutoff=60)}
# load chrom sizes for hg38 assembly
hg38_chrom_sizes <- system.file("extdata", "hg38_chrom.sizes.gz", package = "ChIPbinner")
# load blacklisted regions
blacklisted_regions <- system.file("extdata", "hg38_blacklist.bed.gz", package = "ChIPbinner")
# load WT sample and corresponding input
WT <- system.file("extdata", "Cal27.WT.H3K36me2.10kb.bed.gz", package = "ChIPbinner")
WT_input <- system.file("extdata", "Cal27.WT_input.H3K36me2.10kb.bed.gz", package = "ChIPbinner")
# load NSD1_KO sample and corresponding input
NSD1_KO <- system.file("extdata", "Cal27.NSD1_KO.H3K36me2.10kb.bed.gz", package = "ChIPbinner")
NSD1_KO_input <- system.file("extdata", "Cal27.NSD1_KO_input.H3K36me2.10kb.bed.gz", package = "ChIPbinner")
# generate normalized bigwig for WT sample
norm_bw(
  out_dir = "output_directory",
  chromSizes = hg38_chrom_sizes,
  blacklist = blacklisted_regions,
  cell_line = "Cal27",
  histone_mark = "H3K36me2",
  treated_samp_label = "WT",
  treated_samp_file = WT,
  treated_samp_library_size = 64093770,
  use_control = TRUE,
  control_label = "WT_input",
  control_file = WT_input,
  control_library_size = 52047022,
  raw_count_cutoff = 0,
  window_size = 10,
  pseudocount = 1e-15,
  scaling_factor = 0.450328805
)
# generate normalized bigwig for NSD1-KO sample
norm_bw(
  out_dir = "output_directory",
  chromSizes = hg38_chrom_sizes,
  blacklist = blacklisted_regions,
  cell_line = "Cal27",
  histone_mark = "H3K36me2",
  treated_samp_label = "NSD1_KO",
  treated_samp_file = NSD1_KO,
  treated_samp_library_size = 18598272,
  use_control = TRUE,
  control_label = "NSD1_KO_input",
  control_file = NSD1_KO_input,
  control_library_size = 18674189,
  raw_count_cutoff = 0,
  window_size = 10,
  pseudocount = 1e-15,
  scaling_factor = 0.192272095
)
```

# Generating scatterplots with bins stratified into genic and intergenic regions

After normalizing and converting the binned BED files into bigwigs, we can read them in and generate a scatterplot comparing two cell lines. The scatterplot will annotate genic and intergenic regions accordingly. The resulting figures will be found in <code>/output_directory</code> for the code chunk below. The <code>/path_for_normalized_bigwig</code> will normally be the output directory you indicated when using the <code>norm_bw()</code> function. 

Genic and intergenic regions for <code>hg38</code> and <code>mm10</code> are included with the package and can be accessed as indicated in the code chunk below. 

<b> Note: you will need to adjust the minimum and maximum values for the x- and y-axis accordingly. After you are satisfied with the values for the x- and y-axis, you can then turn off axis annotations by running the function again, but using the parameter <code>show_scales=FALSE</code></b>
```{r,eval=FALSE, tidy=TRUE, tidy.opts=list(width.cutoff=60)}
# load genic regions
genic_regions <- system.file("extdata", "hg38_gene.bed.gz", package = "ChIPbinner")
# load intergenic regions
intergenic_regions <- system.file("extdata", "hg38_intergenic.bed.gz", package = "ChIPbinner")
# generate genic/intergenic scatterplot. here, we are using the normalized bigwigs generated from the previous section. Hence, we will need to indicate the directory where these bigwigs are found.
genic_intergenic_scatterplot(
  path_for_norm_bw = "directory_for_normalized_bigwig",
  out_dir = "output_directory",
  gene = gene,
  intergenic = igr,
  cell_line = "Cal27",
  baseline_samp_label = "WT",
  treated_samp_label = "NSD1_KO",
  histone_mark = "H3K36me2",
  window_size = 10,
  title_of_plot = "Cal27 ChIP-seq H3K36me2",
  xaxis_label = "WT",
  yaxis_label = "NSD1_KO",
  max_x = 1,
  max_y = 1,
  min_x = -5,
  min_y = -5,
  pow = 1.25,
  show_scales = F,
  show_legend = T,
  legend_pos = "left"
)
```

# Generating clusters of similarly-behaving genomic bins

## Processing bigwig files for clustering

Prior to generating clusters, we need to pre-process the normalized bigWig files. This is accomplished using the <code>pre_clus()</code> function. We will continue to use the samples from the previous steps above.
```{r, eval=FALSE}
pre_clust(
  path_for_norm_bw = "directory_for_normalized_bigwig",
  out_dir = "output_directory",
  window_size = 10,
  treated_samp_label = "NSD1_KO",
  baseline_samp_label = "WT",
  cell_line = "Cal27",
  histone_mark = "H3K36me2"
)
```

## Running HDBSCAN to generate clusters

The <code>clus()</code> function can be used to generate clusters of similarly-behaving genomic bins. It is based on an unsupervised learning algorithm to find clusters, or dense regions, of a dataset. More details on the Hierarchical Density-Based Spatial Clustering of Applications with Noise (HDBSCAN) algorithm can be found <a href="https://hdbscan.readthedocs.io/en/latest/index.html">here</a>. The function uses <code>reticulate</code> as an interface to a Python session. Python will need to be installed in your environment prior to running the function. No other actions are required from the user, as the minimal Python packages are automatically installed in an isolated virtual environment specifically designated for the ChIPbinner R package. This minimizes the risk of inadvertently disrupting another Python installation on the userâ€™s system.

<b>It is important to consider this step will require substantial processing memory as well as time </b>. Thus, it is recommended that you use the python-implementation of HDBSCAN in a High-performance Computing server instead. Nevertheless, an example workflow for running HDBSCAN is found below, albeit we are using a downsampled matrix file (10000 data pairs) and using a minimum cluster size of 100. Using the complete matrix file for the density-based scatterplot generated below required substantial processing memory and multiple parallel cores, typically found in a high-performance computing cluster.
```{r,eval=FALSE}
# using a downsampled matrix
generate_clust(
  output_file_name = "sampled.Cal27.WT.NSD1_KO.H3K36me2.10kb",
  out_dir = "output_directory",
  matrix_file = "sampled.Cal27.WT.NSD1_KO.H3K36me2.10kb.mat.csv",
  minpts = 100,
  minsamps = 100,
  cores = 6
)
# using the complete matrix
generate_clust(
  output_file_name = "Cal27.WT.NSD1_KO.H3K36me2.10kb",
  out_dir = "output_directory",
  matrix_file = "Cal27.WT.NSD1_KO.H3K36me2.10kb.mat.csv",
  minpts = 5000,
  minsamps = 5000,
  cores = 6
)
```

## Annotating clusters

After identifying clusters using HDBSCAN, these clusters need to be annotated for use in downstream analysis.
```{r,eval=FALSE}
annotate_clust(
  histone_mark = "H3K36me2",
  window_size = 10,
  cell_line = "Cal27",
  baseline_samp_label = "WT",
  treated_samp_label = "NSD1_KO",
  number_of_clusters = 3,
  matrix_file = "Cal27.WT.NSD1_KO.H3K36me2.10kb.mat.csv",
  pooled_bed_file = "Cal27.WT.NSD1_KO.H3K36me2.10kb.pooled.bed",
  hdbscan_output_file = "clus.Cal27.WT.NSD1_KO.H3K36me2.10kb.5000.5000.txt",
  out_dir = "/output_directory"
)
```

## Generating density-based scatterplots

Finally, a density-based cluster scatterplot can be generated using <code>density_based_scatterplot()</code>. Here, we used the complete matrix of enrichment scores to generate the HBDSCAN output. The complete HDBSCAN output can be called using <code>system.file("extdata","clus.Cal27.WT.NSD1_KO.H3K36me2.10kb.5000.5000.txt.gz",package = "ChIPbinner")</code>
```{r,eval=FALSE}
# load genic regions
genic_regions <- system.file("extdata", "hg38_gene.bed", package = "ChIPbinner")
# load intergenic regions
intergenic_regions <- system.file("extdata", "hg38_intergenic.bed", package = "ChIPbinner")
# generate density-based scatterplot
density_based_scatterplot(
  path_for_norm_bw = "directory_for_normalized_bigwig",
  out_dir = "output_directory",
  treated_samp_label = "NSD1_KO",
  baseline_samp_label = "WT",
  cell_line = "Cal27",
  histone_mark = "H3K36me2",
  annotated_clusters = "annotated_clusters.Cal27.WT.NSD1_KO.H3K36me2.10kb.rda",
  number_of_clusters = 3,
  gene = genic_regions,
  intergenic = intergenic_regions,
  title_of_plot = "H3K36me2",
  window_size = 10,
  pow = 1.25,
  show_legend = TRUE,
  min = -5,
  max = 2,
  bin_size = 50,
  show_scales = FALSE,
  xaxis_label = "WT",
  yaxis_label = "NSD1_KO",
  height_of_figure = 6,
  width_of_figure = 15
)
```

# Overlap enrichment/depletion analysis with annotated clusters of bins

After identifying and annotating clusters of bins, a Fisher's exact test can be used to determine whether these bins overlap a specific class of annotated regions against a background of all bins. The underlying algorithm is based on <a href="https://bioconductor.org/packages/release/bioc/html/LOLA.html">LOLA - locus overlap analysis for enrichment of genomic ranges</a>. The examples below evaluate overlap with <a href="https://useast.ensembl.org/info/genome/index.html">Ensembl</a> annotations genome-wide. However, the user can also evaluate overlap with other functional annotations by changing the <code>functional_db</code> parameter to <code>repeat</code> or <code>ccre</code>. These databases refer to repeats from <a href="https://www.repeatmasker.org/">RepeatMasker</a> and candidate cis-regulatory elements (cCREs) from <a href="https://genome.ucsc.edu/cgi-bin/hgTrackUi?db=mm10&g=encodeCcreCombined">ENCODE</a> respectively. Furthermore, by specifying the <code>region</code> to be either <code>genic</code> or <code>intergenic</code>, the user can evaluate exclusively genic or intergenic bins overlapping a specific class of annotated regions. In these cases, the background is stratified to only genic or intergenic regions to avoid spurious associations to annotations confounded by their predominantly genic or intergenic localization. 

Below is an example of how to calculate overlap enrichment & depletion result of Ensembl annotations with bins found in cluster B identified from the previous analyses. Note that the size of the dots corresponds to the number of bins overlapping the corresponding annotation. The p-value is based on Fisher's exact test of bins overlapping a specific class of annotated regions versus a background of all bins found in both cell lines being compared.
```{r,eval=FALSE}
enrich_clust(
  gene = system.file("extdata", "hg38_gene.bed.gz", package = "ChIPbinner"),
  intergenic = system.file("extdata", "hg38_intergenic.bed.gz", package = "ChIPbinner"),
  assembly = "hg38",
  annotated_clusters = "annotated_clusters.Cal27.WT.NSD1_KO.H3K36me2.10kb.rda",
  query_cluster = "B",
  pooled_bed_file = "Cal27.WT.NSD1_KO.H3K36me2.10kb.pooled.bed",
  functional_db = "ensembl",
  region = "genome_wide",
  cores = 6,
  n_elements = 7,
  cutoff_for_overlap = 100,
  file_plot_name = "genome_wide.enrichment_depletion",
  output_table_name = "genome_wide.enrichment_depletion",
  width_of_plot = 7,
  height_of_plot = 3,
  out_dir = "/output_directory"
)
```
