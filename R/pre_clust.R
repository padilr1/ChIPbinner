#!/usr/bin/env Rscript
#' Title
#' @title Pre-processing the normalized bigWig files prior to generating clusters.
#'
#' @description This function pre-processes the bigWig files: it finds overlapping regions between two bigWig files, removes the bottom and top 1% of bins across the two samples and finally generates a matrix of scores and BED file of coordinates to be used with HDBscan for generating clusters of bins with similar scores.
#'
#' @param path_for_norm_bw Directory where the normalized bigwigs generated by 'norm.bw()' is found.
#' @param out_dir Output directory for the matrix, BED file and preliminary scatterplot.
#' @param window_size The window size in kilobytes - this number must be an integer. For example, use 10 for samples binned in 10 kilobyte (kb) bins.
#' @param treated_samp_label The treated sample name/label.
#' @param baseline_samp_label The baseline sample name/label to which to compare the treated sample. This is usually the wildtype (WT) sample.
#' @param cell_line The cell line of the samples.
#' @param histone_mark The broad histone mark used for the analysis.
#'
#' @return a matrix file of scores for the two samples being compared, a pooled BED file of genomic coordinates for the bins and a preliminary scatterplot of the comparison.
#' @export
#'
#' @include norm_bw.R
#'
#' @example inst/examples/example_pre_clust.R
pre_clust <- function(path_for_norm_bw,
                     out_dir,
                     window_size,
                     treated_samp_label,
                     baseline_samp_label,
                     cell_line,
                     histone_mark) {
  # directory parameters
  path <- paste0(path_for_norm_bw)
  out_dir <- paste0(out_dir)
  # size of window; must be an integer
  window_size <- paste0(".", window_size, "kb.")
  # samples info
  treated_samp_label <- paste0(treated_samp_label)
  baseline_samp_label <- paste0(baseline_samp_label)
  cell_line <- paste0(cell_line)
  mark <- paste0(histone_mark)
  # list files
  s <- list.files(path = path, pattern = window_size, full.names = FALSE, recursive = FALSE) %>%
    tibble(f = .) %>%
    separate(f, c("line", "samp", "mark", NA, NA, NA), "\\.", F) %>%
    mutate(f = file.path(path, f)) %>%
    dplyr::filter(line == cell_line) %>%
    dplyr::filter(mark == mark) %>%
    dplyr::filter(samp == baseline_samp_label | samp == treated_samp_label)
  odr <- c(treated_samp_label, baseline_samp_label)
  s <- s %>%
    dplyr::slice(match(odr, samp))
  # deframe() converts two-column data frames to a named vector or list, using the first column as name and the second column as value. If the input has only one column, an unnamed vector is returned.
  d <- tibble::deframe(s[, c("samp", "f")]) %>%
    lapply(import.bw)
  lapply(d, length)
  # match genomic regions between the baseline sample and the treated sample
  d[[baseline_samp_label]] <- IRanges::subsetByOverlaps(d[[baseline_samp_label]], d[[treated_samp_label]])
  d[[treated_samp_label]] <- IRanges::subsetByOverlaps(d[[treated_samp_label]], d[[baseline_samp_label]])
  lapply(d, length)
  r <- lapply(d, function(y) y[y$score != 0]) %>%
    Reduce(function(a, b) a[IRanges::overlapsAny(a, b)], .) %>%
    GenomicRanges::granges()
  cell_line <- as.character(s$line[[1]])
  mark <- as.character(s$mark[[1]])
  # find overlaps; write the matrix with each line corresponding to the score for a given bin; the pooled BED file contains the genomic coordinates
  split(d, s$line) %>%
    lapply(function(x) {
      o <- lapply(x, function(y) {
        IRanges::findOverlaps(r, y) %>%
          to() %>%
          {
            y[.]
          } %>%
          score()
      }) %>%
        bind_cols() %>%
        `names<-`(c("x", "y"))
      ok <- o$x > quantile(o$x, .01) &
        o$x < quantile(o$x, .99) &
        o$y > quantile(o$y, .01) &
        o$y < quantile(o$y, .99)
      readr::write_csv(o[ok, ], sprintf("%s/%s.%s.%s.%s%smat.csv", out_dir, cell_line, baseline_samp_label, treated_samp_label, mark, window_size), col_names = F)
      rtracklayer::export.bed(r[ok], sprintf("%s/%s.%s.%s.%s%spooled.bed", out_dir, cell_line, baseline_samp_label, treated_samp_label, mark, window_size))
    })
  # read in matrix
  mat <- data.table::fread(sprintf("%s/%s.%s.%s.%s%smat.csv", out_dir, cell_line, baseline_samp_label, treated_samp_label, mark, window_size))
  # open jpeg file
  jpeg(filename = sprintf("%s/%s.%s.%s.%s%ssmoothScatter.jpeg", out_dir, cell_line, baseline_samp_label, treated_samp_label, mark, window_size))
  # create the plot
  smoothScatter(y = mat$V1, x = mat$V2, xlab = baseline_samp_label, ylab = treated_samp_label)
  # close the file
  dev.off()
  return(list(s = s, mark = mark))
  print("bigWig files pre-processed. Output files ready for input into clustering algorithm!")
}
